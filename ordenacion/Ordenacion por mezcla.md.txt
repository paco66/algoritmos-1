# Ordenamiento por Mezcla 
El algoritmo de ordenamiento por mezcla, es un algoritmo de ordenamiento basado en la técnica divide y vencerás. Es de complejidad O(n).

*Su funcionamiento es el siguiente:*

 1. Si la longitud de la lista es 0 ó 1, entonces ya está ordenada. En otro caso:
2. Dividir la lista desordenada en dos sublistas de aproximadamente la mitad del tamaño.
3. Ordenar cada sublista recursivamente aplicando el ordenamiento por mezcla.
4. Mezclar las dos sublistas en una sola lista ordenada.

*Pseudocodigo*
```
    n1=q-p+1
    n2=r-q
    let L[1...n+1] and R[1...n+1] be new arrays
    for i=1 to n1
      L[i]=A[p+i-1]
    for j=1 to n1
      R[j]=A[q+j]
    L[n1+1]=99999
    R[n2+1]=99999
    i=1
    j=1
    for k=p to r
      if L[i]<R[j]
        A[k]=L[i]
        i=i+1
      else A[k] =R
        j=j+1
```    
Tiempo de ejecucion

![GitHub Logo](http://www.wiris.net/demo/editor/render.png?demo-image&mml=%3Cmath%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F1998%2FMath%2FMathML%22%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E2%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E3%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E4%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmfrac%3E%3Cmi%3En%3C%2Fmi%3E%3Cmn%3E2%3C%2Fmn%3E%3C%2Fmfrac%3E%3Cmo%3E%2B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E5%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmfrac%3E%3Cmi%3En%3C%2Fmi%3E%3Cmn%3E2%3C%2Fmn%3E%3C%2Fmfrac%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E6%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmfrac%3E%3Cmi%3En%3C%2Fmi%3E%3Cmn%3E2%3C%2Fmn%3E%3C%2Fmfrac%3E%3Cmo%3E%2B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E7%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmfrac%3E%3Cmi%3En%3C%2Fmi%3E%3Cmn%3E2%3C%2Fmn%3E%3C%2Fmfrac%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E8%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E9%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E10%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E11%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E12%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmi%3En%3C%2Fmi%3E%3Cmo%3E%2B%3C%2Fmo%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E13%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmi%3En%3C%2Fmi%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E14%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmi%3En%3C%2Fmi%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E15%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmi%3En%3C%2Fmi%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E16%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmi%3EC%3C%2Fmi%3E%3Cmn%3E17%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmn%3E10%3C%2Fmn%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%2B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmn%3E6%3C%2Fmn%3E%3Cmi%3En%3C%2Fmi%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmn%3E6%3C%2Fmn%3E%3Cmi%3En%3C%2Fmi%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmo%3E%2B%3C%2Fmo%3E%3Cmo%3E%26%23160%3B%3C%2Fmo%3E%3Cmn%3E10%3C%2Fmn%3E%3Cmspace%20linebreak%3D%22newline%22%2F%3E%3Cmn%3E0%3C%2Fmn%3E%3Cmi%3En%3C%2Fmi%3E%3C%2Fmath%3E)


*Codigo en Scala*
```scala
  def merge(resultado:Array[Int], primero:Array[Int], segundo:Array[Int]) {
    var i:Int = 0
    var j:Int = 0
    for (k <- 0 until resultado.length) {
      if(i<primero.length && j<segundo.length){
        if (primero(i) < segundo(j)){
          resultado(k) = primero(i)
          i=i+1
        } else {
          resultado(k) = segundo(j)
          j=j+1
        }
      }else if(i>=primero.length && j<segundo.length){
        resultado(k) = segundo(j)
        j=j+1
      } else {
        resultado(k) = primero(i)
        i=i+1
      }
    }
  }


```